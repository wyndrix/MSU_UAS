#include "opencv2/core/core.hpp"
#include "opencv2/flann/miniflann.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/photo/photo.hpp"
#include "opencv2/video/video.hpp"
#include "opencv2/features2d/features2d.hpp"
#include "opencv2/objdetect/objdetect.hpp"
#include "opencv2/calib3d/calib3d.hpp"
#include "opencv2/ml/ml.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/contrib/contrib.hpp"
#include "opencv2/core/core_c.h"
#include "opencv2/highgui/highgui_c.h"
#include "opencv2/imgproc/imgproc_c.h"
#include <iostream>
#include <stdio.h>
//#include <tesseract\baseapi.h>
//#include <leptonica\allheaders.h>

using namespace cv;
using namespace std;

//****************************************************************************************************************************************************************************************
//	Global Variables
//****************************************************************************************************************************************************************************************
Mat input;	// Input Matrix
Mat scanoutput, filteroutput, shapeoutput;	// Output Matricies
Vec3b BGR;	// Color of a given pixel
int rows;	// Number of Rows
int cols;	// Number of Cols
int xmax = 0, xmin = 10000, ymax = 0, ymin = 10000; // Used for calculating the positions of the box around the object used to find color
int shape[25];	// Array to hold the shapes discovered
int colorshape[25];	// Array to hold the colors of the objects discovered
int colorletter[25];	// Array to hold the colors of the letters in the objects discovered
int triangle = 0, square = 0, rect = 0, pentagon = 0, hexagon = 0, star = 0, plus_sign = 0, octogon = 0, other = 0;
int pixcolor;	// Color of current pixel: R=0, O=1, Y=2, Grn=3, Blu=4, V=5, Blk=6, W=7, Gry=8, Br=9
int searchcolor;	// Color currently being looked for: R=0, O=1, Y=2, Grn=3, Blu=4, V=5, Blk=6, W=7, Gry=8, Br=9
double pixval, pixvalavg, Bratio, Gratio, Rratio, Blue, Green, Red;		// Variables for different pixel qualities
vector<Point> result; // Points of the contour


//****************************************************************************************************************************************************************************************
//	Approximation Function
//****************************************************************************************************************************************************************************************
int approx(double A, double B, double error, int mode){

	double higherror = 1 + error;
	double lowerror = 1 - error;
	if (mode == 0){
		if ((A >= lowerror*B) && (A <= higherror*B))
			return 1;
		else
			return 0;
	}

	else if (mode == 1){
		if (A*lowerror <= B)
			return 1;
		else
			return 0;
	}
}


//****************************************************************************************************************************************************************************************
//	Calculating Max and Min values for X and Y coordinates of points
//****************************************************************************************************************************************************************************************
int minmaxvals(int n){
	int i;
	cout << n;
	for (i = 0; i <= n; i++){
		if (result[i].x > xmax)
			xmax = result[i].x;
		if (result[i].y > ymax)
			ymax = result[i].y;
		if (result[i].x < xmin)
			xmin = result[i].x;
		if (result[i].y < ymin)
			ymin = result[i].y;
	}
	cout << "X Max: " << xmax << endl;
	cout << "X Min: " << xmin << endl;
	cout << "Y Max: " << ymax << endl;
	cout << "Y Min: " << ymin << endl;
	return 1;
}


//****************************************************************************************************************************************************************************************
//	Shape Function
//****************************************************************************************************************************************************************************************
int shapes(Mat img){

	RNG rng(12345);
	Scalar color(0, 0, 255);
	int j = 0;
	double distance[4];
	double distavg;
	int size = rows*cols;
	vector<vector<Point> > contours;
	vector<Point> result;

	findContours(img, contours, CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);

	for (size_t i = 0; i < contours.size(); i++){
		approxPolyDP(Mat(contours[i]), result, arcLength(Mat(contours[i]), true)*0.02, true);
		if ((contourArea(result) > 300) && (contourArea(result) < size)*0.95){
			
			// Finding Triangles
			if (result.size() == 3){
				triangle++;

				line(input, result[0], result[1], color, 2, 8, 0);
				line(input, result[1], result[2], color, 2, 8, 0);
				line(input, result[2], result[0], color, 2, 8, 0);

			}

			// Finding Quadrilaterals
			else if (result.size() == 4){

				line(input, result[0], result[1], color, 2, 8, 0);
				line(input, result[1], result[2], color, 2, 8, 0);
				line(input, result[2], result[3], color, 2, 8, 0);
				line(input, result[3], result[0], color, 2, 8, 0);


				distance[0] = norm(result[0] - result[1]);
				distance[1] = norm(result[1] - result[2]);
				distance[2] = norm(result[2] - result[3]);
				distance[3] = norm(result[3] - result[0]);

				distavg = ((distance[0] + distance[1] + distance[2] + distance[3]) / 4);

				if ((distance[0] < (distavg*1.05)) && (distance[0] > (distavg*0.95))){
					square++;
				}

				else{
					rect++;
				}

			}

			// Finding Pentagons
			else if (result.size() == 5){
				pentagon++;

				line(input, result[0], result[1], color, 2, 8, 0);
				line(input, result[1], result[2], color, 2, 8, 0);
				line(input, result[2], result[3], color, 2, 8, 0);
				line(input, result[3], result[4], color, 2, 8, 0);
				line(input, result[4], result[0], color, 2, 8, 0);

			}

			// Finding Hexagons
			else if (result.size() == 6){
				hexagon++;
				minmaxvals(result.size());
				line(input, result[0], result[1], color, 2, 8, 0);
				line(input, result[1], result[2], color, 2, 8, 0);
				line(input, result[2], result[3], color, 2, 8, 0);
				line(input, result[3], result[4], color, 2, 8, 0);
				line(input, result[4], result[5], color, 2, 8, 0);
				line(input, result[5], result[0], color, 2, 8, 0);

			}

			// Finding Octogons
			else if (result.size() == 8){
				octogon++;

				line(input, result[0], result[1], color, 2, 8, 0);
				line(input, result[1], result[2], color, 2, 8, 0);
				line(input, result[2], result[3], color, 2, 8, 0);
				line(input, result[3], result[4], color, 2, 8, 0);
				line(input, result[4], result[5], color, 2, 8, 0);
				line(input, result[5], result[6], color, 2, 8, 0);
				line(input, result[6], result[7], color, 2, 8, 0);
				line(input, result[7], result[0], color, 2, 8, 0);
			}

			// Finding Stars
			else if (result.size() == 10){
				star++;

				line(input, result[0], result[1], color, 2, 8, 0);
				line(input, result[1], result[2], color, 2, 8, 0);
				line(input, result[2], result[3], color, 2, 8, 0);
				line(input, result[3], result[4], color, 2, 8, 0);
				line(input, result[4], result[5], color, 2, 8, 0);
				line(input, result[5], result[6], color, 2, 8, 0);
				line(input, result[6], result[7], color, 2, 8, 0);
				line(input, result[7], result[8], color, 2, 8, 0);
				line(input, result[8], result[9], color, 2, 8, 0);
				line(input, result[9], result[0], color, 2, 8, 0);
			}

			// Finding Plus-Symbols
			else if (result.size() == 12){
				plus_sign++;

				line(input, result[0], result[1], color, 2, 8, 0);
				line(input, result[1], result[2], color, 2, 8, 0);
				line(input, result[2], result[3], color, 2, 8, 0);
				line(input, result[3], result[4], color, 2, 8, 0);
				line(input, result[4], result[5], color, 2, 8, 0);
				line(input, result[5], result[6], color, 2, 8, 0);
				line(input, result[6], result[7], color, 2, 8, 0);
				line(input, result[7], result[8], color, 2, 8, 0);
				line(input, result[8], result[9], color, 2, 8, 0);
				line(input, result[9], result[10], color, 2, 8, 0);
				line(input, result[10], result[11], color, 2, 8, 0);
				line(input, result[11], result[0], color, 2, 8, 0);

			}

			else
				other++;
		}
	}

	return 1;
}


//****************************************************************************************************************************************************************************************
//	Color Decider (used in a to-be-made function)
//****************************************************************************************************************************************************************************************
int colorcalc() {
	// Red
	if (approx(Green, Blue, 0.4, 0) && Blue<130 && Green<130 && Red>=200){
		return 0;}

	// Orange
	else if (Blue <= Green*0.6 && Green <= 140 && Red >= 200){
		return 1;}

	// Yellow
	else if (Blue<=175 && Green>=170 && Red>=170){
		return 2;}

	// Green
	else if ((Blue>=80 && Blue<=160) && (Green>=150 && Green<=190) && Red<=30){
		return 3;}

	// Blue
	else if (Blue>= 185 && Green<=200 && Red<=90){
		return 4;}

	// Violet
	else if ((Blue>=140 && Green<=100 && Red>=140)||(Rratio>=0.35 && Bratio>=0.35 && Gratio<0.2 && Red>=95 && Blue>=95)){
		return 5;}

	// Black
	else if ((Blue<40 && Blue>25) && (Green<40 && Green>25) && (Red<40 && Red>25) && Bratio >= 0.29 && Gratio >= 0.29 && Rratio >= 0.29){
		return 6;}

	// White
	else if (Blue>180 && Green>180 && Red>180){
		return 7;}

	// Gray
	else if (Bratio<0.35 && Gratio<0.35 && Rratio<0.35){
		return 8;}

	// other
	else{
		return 9;}
}


//****************************************************************************************************************************************************************************************
//	Filtering
//****************************************************************************************************************************************************************************************
Mat filter(Mat img){
	Mat element1 = getStructuringElement(0, Size(7, 7), Point(1, 1));
	Mat element2 = getStructuringElement(0, Size(5, 5), Point(1, 1));
	Mat element3 = getStructuringElement(0, Size(3, 3), Point(1, 1));
	cvtColor(img, img, CV_RGB2GRAY);
	//blur(img, img, Size(3, 3));
	threshold(img, img, 0, 255, 0);
	int dilation_size = 4;
	Mat morphelement = getStructuringElement(MORPH_RECT, Size(2 * dilation_size + 1, 2 * dilation_size + 1), Point(dilation_size, dilation_size));
	morphologyEx(img, img, MORPH_CLOSE, morphelement);
	erode(img, img, element3);
	dilate(img, img, element1);
	return img;
}


//****************************************************************************************************************************************************************************************
//	Input Scanner
//****************************************************************************************************************************************************************************************
Mat scan(Mat img){

	int i, j;	// For-loop variables
	for (j = 0; j < rows; j++){
		for (i = 0; i < cols; i++){
			// Assign values given individual pixel
			BGR = img.at<Vec3b>(j, i);
			Blue = BGR[0];
			Green = BGR[1];
			Red = BGR[2];
			pixval = Blue + Green + Red;
			if (pixval == 0){
				pixvalavg = 0;
				Bratio = 0;
				Gratio = 0;
				Rratio = 0;
			}

			else{
				pixvalavg = pixval / 3.0;
				Bratio = Blue / pixval;
				Gratio = Green / pixval;
				Rratio = Red / pixval;
			}

			if (((approx(Green, Blue, 0.4, 0) && Blue < 130 && Green < 130 && Red >= 200) || (Blue <= Green*0.6 && Green <= 140 && Red >= 200) || (Blue <= 175 && Green >= 170 && Red >= 170)
				|| ((Blue >= 80 && Blue <= 160) && (Green >= 150 && Green <= 190) && Red <= 30) || (Blue >= 185 && Green <= 200 && Red <= 90) || ((Blue >= 140 && Green <= 100 && Red >= 140) || 
				(Rratio >= 0.35 && Bratio >= 0.35 && Gratio<0.2 && Red >= 95 && Blue >= 95)) || 
				((Blue<40 && Blue>25) && (Green<40 && Green>25) && (Red<40 && Red>25) && Bratio >= 0.29 && Gratio >= 0.29 && Rratio >= 0.29) || (Blue>180 && Green>180 && Red>180))){ // Doesn't include Gray or Brown

				img.at<Vec3b>(j, i)[0] = Blue;
				img.at<Vec3b>(j, i)[1] = Green;
				img.at<Vec3b>(j, i)[2] = Red;
			}

			else{

				img.at<Vec3b>(j, i)[0] = 0;
				img.at<Vec3b>(j, i)[1] = 0;
				img.at<Vec3b>(j, i)[2] = 0;
			}
		}
	}

	return img;
}


//****************************************************************************************************************************************************************************************
//	Main
//****************************************************************************************************************************************************************************************
int main(){

	input = imread("C:/temp/msuus/Realpic5.jpg", CV_LOAD_IMAGE_COLOR);
	scanoutput = input.clone();
	rows = input.rows;
	cols = input.cols;

	cout << "Scanning for colors..." << endl;
	scanoutput = scan(scanoutput);
	imwrite("C:/temp/msuus/colorfindtest/scanoutput.jpg", scanoutput);
	imshow("Scaned Output", scanoutput);

	cout << "Filtering..." << endl;
	filteroutput = filter(scanoutput);
	imwrite("C:/temp/msuus/colorfindtest/filteroutput.jpg", filteroutput);
	imshow("Filter Output", filteroutput);

	cout << "Detecting Shapes..." << endl;
	shapes(filteroutput);
	imwrite("C:/temp/msuus/colorfindtest/overalloutput.jpg", input);
	imshow("Shapes", input);

	waitKey();
}
